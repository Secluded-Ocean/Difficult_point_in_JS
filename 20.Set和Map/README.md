# Set

## 一、基本API

- 使用new关键字和Set构造函数可以创建一个空集合，如果想在创建的同时初始化实例，则可以给Set构造函数传入一个可迭代对象；
- 初始化之后，可以使用add()添加值，使用has()进行查询，通过size取得元素数量，以及使用delete()和clear()删除元素；
- add()返回集合的实例，可以将多个add()操作连缀起来；
- Set可以包含任何JS数据类型作为值（与Map类似），集合内部使用严格对象相等的标准来检查匹配性；

## 二、顺序与迭代

- Set会维护值插入时的顺序，因此支持按顺序迭代。
- 集合实例可以提供一个迭代器，能以插入顺序生成集合内容。可以通过values()方法及其别名方法keys()取得这个迭代器。
- 也可以直接使用[... Set]对集合实例进行扩展操作，把集合转换为数组；
- 集合的entries()方法返回一个迭代器，可以按照插入顺序产生包含两个元素的数组；

# WeakSet

## 一、基本API

- 弱集合中的值**只能是Object或者继承自Object的类型**，尝试使用非对象设置值会抛出TypeError
- 初始化之后可以使用add()再添加新值，可以使用has()查询，也可以使用delete()删除；

## 二、弱值

- WeakSet中“Weak”表示弱集合的值是“弱弱地拿着”，说明这些值不属于正是的引用，不会阻止垃圾回收。

  - ```JS
    const ws = new WeakSet()
    ws.add({})
    ```

    add()方法初始化了一个新对象，并将它作为一个值，因为没有指向这个值的其他引用，所以当这行代码执行完成后，这个对象就会被当做垃圾回收，然后这个值就从弱集合中消失了，使其成为一个空集合。

  - ```JS
    const ws = new WeakSet()
    
    const container = {
        val: {}				// container维护着一个对弱集合值的引用，因此这个对象值不会成为垃圾回收的目标
    }
    
    ws.add(container.val)
    
    function removeReference() {	// 如果调用removeReference()，就会摧毁对象的最后一个引用
        container.val = null		// 垃圾回收程序就可以把这个值清理掉	
    }
    ```

- **不可迭代值：**

  - 因为WeakSet中的值任何时候都可能被销毁，所以没必要提供迭代其值的能力。当然也用不着像clear()这样一次性销毁所有值的方法。
  - 因为不能迭代，所以如果不知道对象引用，就不能从弱集合中取得值。
  - WeakSet之所以限制只能用对象作为值，是为了保证只有通过值对象的引用才能取得值。如果允许原始值，就没办法区分初始化时使用的字符串字面量和初始化之后使用的一个相等的字符串了。


## 三、WeakSet的应用

主要用在给对象打标签时：

```JS
const disabledElements = new Set();
const loginButton = document.querySelector('#login');

// 通过加入对应集合，给这个节点打上“禁用”标签
disabledElements.add(loginButton);
```

这样，通过查询元素在不在`disabledElements`中就能知道它是不是被禁用了，但如果元素从DOM中被删除了，它的引用却仍然保存在Set中，因此垃圾回收程序也无法回收它。

为了让垃圾回收程序回收元素的内存，可以在这里使用WeakSet：

```JS
const disabledElements = new WeakSet();
const loginButton = document.querySelector('#login');

// 通过加入对应集合，给这个节点打上“禁用”标签
disabledElements.add(loginButton);
```

这样，只要WeakSet中任何元素从DOM树种被删除，垃圾回收程序就可以忽略其存在，而立即释放内存（假设没有其他地方引用这个对象）



# Map

## 一、基本API

- 使用new关键字和Map()构造函数可以创建一个空映射
- 可以给Map构造函数传入一个可迭代对象，需要包含键值对数组，可迭代对象中的每个键值对都会按照迭代顺序插入到新映射实例中
- set()方法可以添加键值对，get()和has()可以进行查询，size属性可以获取映射中的键值对数量，还可以使用delete()和clear()删除值。
- Map可以使用**任何JS数据类型作为键**（Object只能使用数值、字符串或符号）

## 二、顺序与迭代

- **Map实例会维护键值对的插入循序，可以根据插入顺序执行迭代操作（与Object类型的一个主要差异）**
- 映射实例可以提供一个迭代器，能以插入顺序生成[key, value]形式的数组。可以通过entries()方法取得这个迭代器。

## 三、Object与Map

1. 内存占用：不同浏览器情况不同，但给定固定大小的内存，**Map大约可以比Object多存储50%的键值对**
2. 插入性能：Map比Object稍快一点，如果**代码涉及大量插入操作，那Map的性能更佳**
3. 查找速度：
   - 如果只包含少量键值对，则Object有时候更快
   - 在把Object当成数组使用的情况下（比如使用连续整数作为属性），浏览器引擎可以进行优化，在内存中使用更高效的布局。
   - 如果**代码涉及大量查找操作，选择Object更好一点**
4. 删除性能：
   - 使用delete删除Object属性的性能一直不太好，但Map的delete()操作比插入和查找更快
   - **如果代码涉及大量删除操作，那一定要选Map**

# WeakMap

## 一、弱键

- “Weak”表示弱映射的键是“弱弱地拿着”，也就是说这些键不属于正式的引用，不会阻止垃圾回收。

- 但是，弱映射的值不是“弱弱地拿着”的。

- 只要键存在，键值对就会存在于映射中，并被当作对值的引用，因此不会被当作垃圾回收。

  - ```JS
    const wm = new WeakMap()
    ws.set({}, "val")
    ```

    set()方法初始化了一个新对象，并将它作为一个字符串的键，因为没有指向这个对象的其他引用，所以当这行代码执行完成后，这个对象键就会被当做垃圾回收，然后这个键值对就从弱映射中消失了，使其成为一个空映射。

    在这个例子中，因为值也没被引用，所以这对键值对被破坏后，值本身也会成为垃圾回收的目标。

  - ```JS
    const wm = new WeakMap()
    
    const container = {
        key: {}				// container维护着一个对弱映射键的引用，因此这个对象键不会成为垃圾回收的目标
    }
    
    wm.set(container.key, "val")
    
    function removeReference() {	// 如果调用removeReference()，就会摧毁对象的最后一个引用
        container.val = null		// 垃圾回收程序就可以把这个值清理掉	
    }
    ```

## 二、不可迭代键
